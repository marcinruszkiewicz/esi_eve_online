defmodule EsiEveOnline.Streaming do
  @moduledoc """
  Convenience functions for streaming paginated ESI endpoints.
  
  This module provides easy-to-use functions for common streaming patterns
  without modifying the autogenerated API modules.
  """

  @doc """
  Stream all character assets with automatic pagination.

  This function provides a convenient way to get all character assets across
  all pages as a stream. It automatically handles pagination for you.

  ## Parameters

  - `character_id` - The character ID
  - `opts` - Request options (same as `Esi.Api.Characters.assets/2`)

  ## Examples

      # Get all assets as a list
      EsiEveOnline.Streaming.character_assets(12345, token: "access_token")
      |> Enum.to_list()

      # Process assets as they come in
      EsiEveOnline.Streaming.character_assets(12345, token: "access_token")
      |> Stream.map(& &1.type_id)
      |> Enum.uniq()

      # Take only the first 100 assets
      EsiEveOnline.Streaming.character_assets(12345, token: "access_token")
      |> Stream.take(100)
      |> Enum.to_list()
  """
  @spec character_assets(integer, keyword) :: Enumerable.t()
  def character_assets(character_id, opts \\ []) do
    stream_paginated("/characters/#{character_id}/assets", opts)
  end

  @doc """
  Stream all corporation assets with automatic pagination.

  This function provides a convenient way to get all corporation assets across
  all pages as a stream. It automatically handles pagination for you.

  ## Parameters

  - `corporation_id` - The corporation ID
  - `opts` - Request options (same as `Esi.Api.Corporations.assets/2`)

  ## Examples

      # Get all assets as a list
      EsiEveOnline.Streaming.corporation_assets(12345, token: "access_token")
      |> Enum.to_list()

      # Process assets as they come in
      EsiEveOnline.Streaming.corporation_assets(12345, token: "access_token")
      |> Stream.map(& &1.type_id)
      |> Enum.uniq()

      # Take only the first 100 assets
      EsiEveOnline.Streaming.corporation_assets(12345, token: "access_token")
      |> Stream.take(100)
      |> Enum.to_list()
  """
  @spec corporation_assets(integer, keyword) :: Enumerable.t()
  def corporation_assets(corporation_id, opts \\ []) do
    stream_paginated("/corporations/#{corporation_id}/assets", opts)
  end

  @doc """
  Stream all universe groups with automatic pagination.

  This function provides a convenient way to get all universe groups across
  all pages as a stream. No authentication required.

  ## Parameters

  - `opts` - Request options

  ## Examples

      # Get all groups as a list
      EsiEveOnline.Streaming.universe_groups()
      |> Enum.to_list()

      # Take only the first 50 groups
      EsiEveOnline.Streaming.universe_groups()
      |> Stream.take(50)
      |> Enum.to_list()
  """
  @spec universe_groups(keyword) :: Enumerable.t()
  def universe_groups(opts \\ []) do
    stream_paginated("/universe/groups", opts)
  end

  @doc """
  Stream all universe types with automatic pagination.

  This function provides a convenient way to get all universe types across
  all pages as a stream. No authentication required.

  ## Parameters

  - `opts` - Request options

  ## Examples

      # Get all types as a list
      EsiEveOnline.Streaming.universe_types()
      |> Enum.to_list()

      # Take only the first 100 types
      EsiEveOnline.Streaming.universe_types()
      |> Stream.take(100)
      |> Enum.to_list()
  """
  @spec universe_types(keyword) :: Enumerable.t()
  def universe_types(opts \\ []) do
    stream_paginated("/universe/types", opts)
  end

  @doc """
  Stream all market orders for a region with automatic pagination.

  This function provides a convenient way to get all market orders across
  all pages as a stream. No authentication required.

  ## Parameters

  - `region_id` - The region ID
  - `opts` - Request options

  ## Examples

      # Get all orders for a region
      EsiEveOnline.Streaming.market_orders(10000002)
      |> Enum.to_list()

      # Filter by type ID
      EsiEveOnline.Streaming.market_orders(10000002)
      |> Stream.filter(& &1.type_id == 34)
      |> Enum.to_list()
  """
  @spec market_orders(integer, keyword) :: Enumerable.t()
  def market_orders(region_id, opts \\ []) do
    stream_paginated("/markets/#{region_id}/orders", opts)
  end

  @doc """
  Stream all killmails with automatic pagination.

  This function provides a convenient way to get all killmails across
  all pages as a stream. No authentication required.

  ## Parameters

  - `opts` - Request options

  ## Examples

      # Get recent killmails
      EsiEveOnline.Streaming.killmails()
      |> Stream.take(100)
      |> Enum.to_list()

      # Filter by ship type
      EsiEveOnline.Streaming.killmails()
      |> Stream.filter(& &1.victim.ship_type_id == 587)
      |> Enum.take(50)
      |> Enum.to_list()
  """
  @spec killmails(keyword) :: Enumerable.t()
  def killmails(opts \\ []) do
    stream_paginated("/killmails/recent", opts)
  end

  @doc """
  Stream all wars with automatic pagination.

  This function provides a convenient way to get all wars across
  all pages as a stream. No authentication required.

  ## Parameters

  - `opts` - Request options

  ## Examples

      # Get all wars
      EsiEveOnline.Streaming.wars()
      |> Enum.to_list()

      # Filter active wars
      EsiEveOnline.Streaming.wars()
      |> Stream.filter(& &1.finished == nil)
      |> Enum.to_list()
  """
  @spec wars(keyword) :: Enumerable.t()
  def wars(opts \\ []) do
    stream_paginated("/wars", opts)
  end

  @doc """
  Stream all contracts for a character with automatic pagination.

  This function provides a convenient way to get all character contracts across
  all pages as a stream. Requires authentication.

  ## Parameters

  - `character_id` - The character ID
  - `opts` - Request options

  ## Examples

      # Get all character contracts
      EsiEveOnline.Streaming.character_contracts(12345, token: "access_token")
      |> Enum.to_list()

      # Filter by contract type
      EsiEveOnline.Streaming.character_contracts(12345, token: "access_token")
      |> Stream.filter(& &1.type == "item_exchange")
      |> Enum.to_list()
  """
  @spec character_contracts(integer, keyword) :: Enumerable.t()
  def character_contracts(character_id, opts \\ []) do
    stream_paginated("/characters/#{character_id}/contracts", opts)
  end

  @doc """
  Stream all corporation contracts with automatic pagination.

  This function provides a convenient way to get all corporation contracts across
  all pages as a stream. Requires authentication.

  ## Parameters

  - `corporation_id` - The corporation ID
  - `opts` - Request options

  ## Examples

      # Get all corporation contracts
      EsiEveOnline.Streaming.corporation_contracts(12345, token: "access_token")
      |> Enum.to_list()

      # Filter by contract type
      EsiEveOnline.Streaming.corporation_contracts(12345, token: "access_token")
      |> Stream.filter(& &1.type == "auction")
      |> Enum.to_list()
  """
  @spec corporation_contracts(integer, keyword) :: Enumerable.t()
  def corporation_contracts(corporation_id, opts \\ []) do
    stream_paginated("/corporations/#{corporation_id}/contracts", opts)
  end

  # Private function to create a stream for paginated endpoints
  defp stream_paginated(path, opts) do
    # Extract query parameters from opts (excluding non-query options)
    query_params = opts
    |> Keyword.drop([:token, :user_agent, :timeout, :retries, :base_url])
    |> Enum.into([])
    
    # Check if this endpoint supports pagination by looking for page parameter
    supports_pagination = supports_pagination?(path, opts)
    
    if supports_pagination do
      stream_paginated_impl(path, query_params, opts)
    else
      stream_single_impl(path, query_params, opts)
    end
  end

  # Private function to create a stream for paginated endpoints
  defp stream_paginated_impl(path, query_params, opts) do
    Stream.resource(
      fn -> {path, query_params, opts, 1} end,
      fn
        :halt -> {:halt, nil}
        {path, query_params, opts, page} ->
          case get_with_headers(path, Keyword.put(query_params, :page, page) ++ opts) do
            {:ok, data, max_pages} ->
              next_page = page + 1
              next_state = if next_page > max_pages, do: :halt, else: {path, query_params, opts, next_page}
              {data, next_state}
            
            {:error, error} ->
              raise "Stream request failed: #{inspect(error)}"
          end
      end,
      & &1
    )
  end

  # Private function to create a stream for non-paginated endpoints
  defp stream_single_impl(path, query_params, opts) do
    Stream.resource(
      fn -> {path, query_params, opts} end,
      fn
        :halt -> {:halt, nil}
        {path, query_params, opts} ->
          case get(path, query_params ++ opts) do
            {:ok, data} ->
              {List.wrap(data), :halt}
            
            {:error, error} ->
              raise "Stream request failed: #{inspect(error)}"
          end
      end,
      & &1
    )
  end

  # Determine if an endpoint supports pagination
  # This is a heuristic based on common paginated endpoints
  defp supports_pagination?(path, opts) do
    # Check if page parameter is explicitly provided
    if Keyword.has_key?(opts, :page) do
      true
    else
      # Heuristic: common paginated endpoints
      paginated_patterns = [
        "/characters/",
        "/corporations/",
        "/universe/groups",
        "/universe/types",
        "/universe/regions",
        "/universe/constellations",
        "/universe/systems",
        "/universe/stations",
        "/universe/structures",
        "/markets/",
        "/killmails/",
        "/wars/",
        "/faction_warfare/",
        "/industry/",
        "/loyalty/",
        "/sovereignty/",
        "/incursions/",
        "/insurance/",
        "/route/",
        "/dogma/",
        "/ui/",
        "/status/",
        "/fleet/",
        "/contracts/",
        "/alliances/"
      ]
      
      Enum.any?(paginated_patterns, fn pattern ->
        String.contains?(path, pattern)
      end)
    end
  end

  # Delegate to the main EsiEveOnline module functions
  # This will work at runtime even if there are compilation warnings
  defp get(path, opts) do
    # Use the main module functions
    EsiEveOnline.get(path, opts)
  end

  defp get_with_headers(path, opts) do
    # Use the main module functions
    EsiEveOnline.get_with_headers(path, opts)
  end
end